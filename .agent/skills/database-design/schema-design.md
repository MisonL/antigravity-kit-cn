# Schema（模式）设计原则

> 范式化、主键选择、时间戳策略以及关系建模。

## 范式化决策

```
何时进行范式化（normalization，拆分表）：
├── 数据在多行之间重复出现
├── 更新操作需要修改多个地方
├── 实体间关系清晰明确
├── 查询模式能从拆分中获益（如减少冗余扫描）

何时进行反范式化（denormalization，嵌入/重复数据）：
├── 读性能至关重要（减少 JOIN）
├── 数据极少发生变更
├── 相关数据总是被一起获取
├── 需要极简的查询语句
```

## 主键选择

| 类型 | 使用场景 |
| ---- | -------- |
| **UUID** | 分布式系统，安全性考虑（不泄露数据量） |
| **ULID** | 具备 UUID 性质 + 可按时间排序 |
| **自增（auto-increment）** | 简单应用，单一数据库环境 |
| **自然主键（natural key）** | 极少使用（具有业务含义的列） |

## 时间戳策略

```
建议为每一张表添加：
├── created_at → 创建时间
├── updated_at → 最后修改时间
└── deleted_at → 软删除时间（如果需要）

务必使用 TIMESTAMPTZ（带时区）而非原生 TIMESTAMP
```

## 关系类型

| 类型 | 场景 | 实现方式 |
| ---- | ---- | -------- |
| **一对一（One-to-One）** | 扩展数据 | 独立表并通过外键关联 |
| **一对多（One-to-Many）** | 父子、归属关系 | 在子表上建立外键 |
| **多对多（Many-to-Many）** | 双方均有复数关联 | 建立关联表（Junction table） |

## 外键删除策略

```
├── CASCADE → 随父记录一起级联删除子记录
├── SET NULL → 父记录删除后，子记录关联字段设为 NULL（变孤儿）
├── RESTRICT → 如果存在子记录，则阻止删除父记录
└── SET DEFAULT → 父记录删除后，子记录设为默认值
```
