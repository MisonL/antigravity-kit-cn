---
name: nodejs-best-practices
description: Node.js 开发原则与决策。框架选择、异步模式、安全与架构。教导思考而非复制。
allowed-tools: Read, Write, Edit, Glob, Grep
---

# Node.js Best Practices - Node.js 最佳实践

> 2025 年 Node.js 开发的原则与决策。
> **学会思考，而不是死记代码模式。**

---

## ⚠️ 如何使用此 Skill

本 Skill 教授 **决策原则**，而非供复制的固定代码。

- 不清楚时 **询问** 用户偏好
- 根据 **上下文** 选择框架/模式
- 不要每次都默认使用相同的解决方案

---

## 1. 框架选择 (2025)

### 决策树

```
你要构建什么？
│
├── 边缘/Serverless (Cloudflare, Vercel)
│   └── Hono (零依赖, 超快冷启动)
│
├── 高性能 API
│   └── Fastify (比 Express 快 2-3 倍)
│
├── 企业级/团队熟悉度
│   └── NestJS (结构化, DI, 装饰器)
│
├── 遗留/稳定/最大生态系统
│   └── Express (成熟, 中间件最多)
│
└── 全栈与前端
    └── Next.js API Routes 或 tRPC
```

### 比较原则

| 因素           | Hono             | Fastify | Express        |
| -------------- | ---------------- | ------- | -------------- |
| **最适合**     | Edge, Serverless | 性能    | 遗留项目, 学习 |
| **冷启动**     | 最快             | 快      | 中等           |
| **生态系统**   | 增长中           | 好      | 最大           |
| **TypeScript** | 原生             | 优秀    | 好             |
| **学习曲线**   | 低               | 中      | 低             |

### 选择时要问的问题：

1. 部署目标是什么？
2. 冷启动时间关键吗？
3. 团队有现有经验吗？
4. 有遗留代码需要维护吗？

---

## 2. 运行时考量 (2025)

### 原生 TypeScript

```
Node.js 22+: --experimental-strip-types
├── 直接运行 .ts 文件
├── 简单项目无需构建步骤
└── 考虑用于: 脚本, 简单 API
```

### 模块系统决策

```
ESM (import/export)
├── 现代标准
├── 更好的 Tree-shaking
├── 异步模块加载
└── 用于: 新项目

CommonJS (require)
├── 遗留兼容性
├── 更多 npm 包支持
└── 用于: 现有代码库, 一些边缘情况
```

### 运行时选择

| 运行时      | 最适合                    |
| ----------- | ------------------------- |
| **Node.js** | 通用目的, 最大生态系统    |
| **Bun**     | 性能, 内置打包器          |
| **Deno**    | 安全优先, 内置 TypeScript |

---

## 3. 架构原则 (Architecture Principles)

### 分层结构概念

```
请求流 (Request Flow):
│
├── 控制器/路由层 (Controller/Route Layer)
│   ├── 处理 HTTP 细节
│   ├── 边界处的输入验证
│   └── 调用服务层
│
├── 服务层 (Service Layer)
│   ├── 业务逻辑
│   ├── 框架无关
│   └── 调用仓储层
│
└── 仓储层 (Repository Layer)
    ├── 仅数据访问
    ├── 数据库查询
    └── ORM 交互
```

### 为什么这很重要：

- **可测试性**: 独立 Mock 各层
- **灵活性**: 更换数据库而不触及业务逻辑
- **清晰度**: 每层单一职责

### 何时简化：

- 小脚本 → 单文件 OK
- 原型 → 较少结构可接受
- 始终问："这会增长吗？"

---

## 4. 错误处理原则 (Error Handling Principles)

### 集中式错误处理

```
模式:
├── 创建自定义错误类
├── 从任何层抛出
├── 在顶层捕获 (中间件)
└── 格式化一致的响应
```

### 错误响应哲学

```
客户端获取:
├── 适当的 HTTP 状态码
├──以此编程处理的错误代码
├── 用户友好的消息
└── 无内部细节 (安全!)

日志记录获取:
├── 完整堆栈跟踪 (Stack Trace)
├── 请求上下文
├── 用户 ID (如果适用)
└── 时间戳
```

### 状态码选择

| 情况       | 状态码 | 何时使用                  |
| ---------- | ------ | ------------------------- |
| 输入错误   | 400    | 客户端发​​送了无效数据    |
| 未认证     | 401    | 缺少凭证或凭证无效        |
| 无权限     | 403    | 认证有效，但不允许        |
| 未找到     | 404    | 资源不存在                |
| 冲突       | 409    | 重复或状态冲突            |
| 验证       | 422    | Schema 有效但业务规则失败 |
| 服务器错误 | 500    | 我们的错，记录一切        |

---

## 5. 异步模式原则 (Async Patterns Principles)

### 何时使用每种模式

| 模式                 | 何时使用             |
| -------------------- | -------------------- |
| `async/await`        | 顺序异步操作         |
| `Promise.all`        | 并行独立操作         |
| `Promise.allSettled` | 并行且允许部分失败   |
| `Promise.race`       | 超时或第一个响应胜出 |

### 事件循环感知

```
I/O 密集型 (异步有帮助):
├── 数据库查询
├── HTTP 请求
├── 文件系统
└── 网络操作

CPU 密集型 (异步没帮助):
├── 加密操作
├── 图像处理
├── 复杂计算
└── → 使用 Worker 线程或卸载
```

### 避免阻塞事件循环

- 绝不在生产环境使用同步方法 (fs.readFileSync 等)
- 卸载 CPU 密集型工作
- 对大数据使用流 (Streaming)

---

## 6. 验证原则 (Validation Principles)

### 在边界处验证

```
哪里验证:
├── API 入口点 (请求体/参数)
├── 数据库操作之前
├── 外部数据 (API 响应, 文件上传)
└── 环境变量 (启动时)
```

### 验证库选择

| 库          | 最适合                        |
| ----------- | ----------------------------- |
| **Zod**     | TypeScript 优先, 推断         |
| **Valibot** | 更小的包体积 (Tree-shakeable) |
| **ArkType** | 性能关键                      |
| **Yup**     | 现有 React Form 使用          |

### 验证哲学

- 快速失败 (Fail fast): 尽早验证
- 具体明确: 清晰的错误消息
- 不要信任: 即使是"内部"数据

---

## 7. 安全原则 (Security Principles)

### 安全检查清单 (非代码)

- [ ] **输入验证**: 验证所有输入
- [ ] **参数化查询**: SQL 无字符串拼接
- [ ] **密码哈希**: bcrypt 或 argon2
- [ ] **JWT 验证**: 始终验证签名和过期
- [ ] **速率限制**: 防止滥用
- [ ] **安全头**: Helmet.js 或同等工具
- [ ] **HTTPS**: 生产环境到处都是
- [ ] **CORS**: 正确配置
- [ ] **密钥**: 仅限环境变量
- [ ] **依赖**: 定期审计

### 安全心态

```
什么都不信 (Trust nothing):
├── 查询参数 → 验证
├── 请求体 → 验证
├── Headers → 验证
├── Cookies → 验证
├── 文件上传 → 扫描
└── 外部 API → 验证响应
```

---

## 8. 测试原则 (Testing Principles)

### 测试策略选择

| 类型            | 目的     | 工具              |
| --------------- | -------- | ----------------- |
| **Unit**        | 业务逻辑 | node:test, Vitest |
| **Integration** | API 端点 | Supertest         |
| **E2E**         | 完整流程 | Playwright        |

### 测试什么 (优先级)

1. **关键路径**: 认证, 支付, 核心业务
2. **边缘情况**: 空输入, 边界
3. **错误处理**: 失败时会发生什么？
4. **不值得测试**: 框架代码, 琐碎的 getter

### 内置测试运行器 (Node.js 22+)

```
node --test src/**/*.test.ts
├── 无外部依赖
├── 良好的覆盖率报告
└── 可用 Watch 模式
```

---

## 10. 避免的反模式 (Anti-Patterns to Avoid)

### ❌ 不要 (DON'T):

- 在新的边缘项目中使用 Express (使用 Hono)
- 在生产代码中使用同步方法
- 将业务逻辑放在控制器中
- 跳过输入验证
- 硬编码密钥
- 无验证地信任外部数据
- 用 CPU 工作阻塞事件循环

### ✅ 要 (DO):

- 根据上下文选择框架
- 不清楚时询问用户偏好
- 为增长的项目使用分层架构
- 验证所有输入
- 使用环境变量存储密钥
- 优化前先分析 (Profile)

---

## 11. 决策检查清单 (Decision Checklist)

实施前：

- [ ] **询问过用户关于技术栈的偏好？**
- [ ] **为当前上下文选择了框架？** (不仅仅是默认)
- [ ] **考虑了部署目标？**
- [ ] **规划了错误处理策略？**
- [ ] **确定了验证点？**
- [ ] **考虑了安全需求？**

---

> **记住**：Node.js 最佳实践是关于决策，而不是死记硬背模式。每个项目都值得根据其需求进行新的考虑。
