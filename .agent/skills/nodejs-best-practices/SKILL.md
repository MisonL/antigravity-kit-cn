---
name: nodejs-best-practices
description: Node.js 开发原则与决策。框架选择、异步模式、安全与架构。教导思考而非复制。
allowed-tools: Read, Write, Edit, Glob, Grep
---

# Node.js 最佳实践

> 2025 年 Node.js (Node.js 运行时) 开发的原则与决策。
> **学会思考，而不是死记代码模式。**

---

## ⚠️ 如何使用此技能 (Skill)

本技能教授的是 **决策原则**，而非可以直接复制的固定代码。

- 不清楚时 **询问** 用户偏好
- 根据 **上下文 (Context)** 选择框架/模式
- 不要每次都默认使用相同的解决方案

---

## 1. 框架选择 (2025)

### 决策树

```
你要构建什么？
│
├── 边缘 (Edge) / 无服务器 (Serverless) (Cloudflare, Vercel)
│   └── Hono (零依赖，超快冷启动)
│
├── 高性能 API
│   └── Fastify (比 Express 快 2-3 倍)
│
├── 企业级/团队熟悉度
│   └── NestJS (结构化，依赖注入 (DI)，装饰器)
│
├── 遗留/稳定/最大生态系统
│   └── Express (成熟，中间件最多)
│
└── 带有前端的全栈
    └── Next.js API 路由或 tRPC
```

### 比较原则

| 因素           | Hono           | Fastify | Express        |
| -------------- | -------------- | ------- | -------------- |
| **最适合**     | 边缘, 无服务器 | 性能    | 遗留系统, 学习 |
| **冷启动**     | 最快           | 快      | 中等           |
| **生态系统**   | 增长中         | 好      | 最大           |
| **TypeScript** | 原生           | 优秀    | 好             |
| **学习曲线**   | 低             | 中      | 低             |

### 选型提问：

1. 部署目标是什么？
2. 冷启动时间是否关键？
3. 团队是否有现有经验？
4. 是否有遗留代码需要维护？

---

## 2. 运行时考量 (2025)

### 原生 TypeScript

```
Node.js 22+: --experimental-strip-types
├── 直接运行 .ts 文件
├── 简单项目无需构建步骤
└── 考虑用于：脚本, 简单 API
```

### 模块系统决策

```
ESM (import/export)
├── 现代标准
├── 更好的 Tree-shaking (摇树优化)
├── 异步模块加载
└── 用于：新项目

CommonJS (require)
├── 遗留兼容性
├── 更多 npm 包支持
└── 用于：现有代码库, 一些边缘情况
```

### 运行时选择

| 运行时      | 最适合                     |
| ----------- | -------------------------- |
| **Node.js** | 通用目的，最大生态系统     |
| **Bun**     | 性能，内置打包器 (Bundler) |
| **Deno**    | 安全优先，内置 TypeScript  |

---

## 3. 架构原则

### 分层结构概念

```
请求流 (Request Flow):
│
├── 控制器/路由层 (Controller/Route Layer)
│   ├── 处理 HTTP 细节
│   ├── 边界处的输入验证
│   └── 调用服务层
│
├── 服务层 (Service Layer)
│   ├── 业务逻辑
│   ├── 框架无关
│   └── 调用仓储层
│
└── 仓储层 (Repository Layer)
    ├── 仅数据访问
    ├── 数据库查询
    └── ORM (对象关系映射) 交互
```

### 为什么这很重要：

- **可测试性**：独立模拟 (Mock) 各层
- **灵活性**：更换数据库而不触及业务逻辑
- **清晰度**：每层承担单一职责

### 何时简化：

- 小脚本 → 单文件即可
- 原型 → 较少结构可接受
- 始终问：“这会增长吗？”

---

## 4. 错误处理原则

### 集中式错误处理

```
模式：
├── 创建自定义错误类 (Error classes)
├── 从任何层抛出
├── 在顶层捕获（中间件）
└── 格式化一致的响应
```

### 错误响应哲学

```
客户端获取：
├── 适当的 HTTP 状态码
├── 用于编程处理的错误代码
├── 用户友好的消息
└── **禁止** 内部细节（安全因素！）

日志获取：
├── 完整堆栈跟踪 (Stack trace)
├── 请求上下文
├── 用户 ID（如果适用）
└── 时间戳
```

### 状态码选择

| 情况       | 状态码 | 何时使用                         |
| ---------- | ------ | -------------------------------- |
| 错误输入   | 400    | 客户端发送了无效数据             |
| 未认证     | 401    | 缺少凭证或凭证无效               |
| 无权限     | 403    | 认证有效，但不允许访问           |
| 未找到     | 404    | 资源不存在                       |
| 冲突       | 409    | 重复或状态冲突                   |
| 校验失败   | 422    | Schema (模式) 有效但业务规则失败 |
| 服务器错误 | 500    | 我们的错，记录一切               |

---

## 5. 异步模式原则

### 何时使用每种模式

| 模式                 | 何时使用             |
| -------------------- | -------------------- |
| `async/await`        | 顺序异步操作         |
| `Promise.all`        | 并行独立操作         |
| `Promise.allSettled` | 并行且允许部分失败   |
| `Promise.race`       | 超时或第一个响应胜出 |

### 事件循环 (Event Loop) 感知

```
I/O 密集型（异步有帮助）：
├── 数据库查询
├── HTTP 请求
├── 文件系统
└── 网络操作

CPU 密集型（异步没帮助）：
├── 加密操作
├── 图像处理
├── 复杂计算
└── → 使用工作线程 (Worker threads) 或卸载
```

### 避免阻塞事件循环

- 绝不在生产环境使用同步方法（如 `fs.readFileSync` 等）
- 卸载 CPU 密集型工作
- 对大数据使用流 (Streaming)

---

## 6. 验证原则

### 在边界处验证

```
哪里验证：
├── API 入口点（请求体/参数）
├── 数据库操作之前
├── 外部数据（API 响应，文件上传）
└── 环境变量（启动时）
```

### 验证库选择

| 库          | 最适合                        |
| ----------- | ----------------------------- |
| **Zod**     | TypeScript 优先, 类型推断     |
| **Valibot** | 更小的包体积 (Tree-shakeable) |
| **ArkType** | 性能关键                      |
| **Yup**     | 现有 React 表单使用           |

### 验证哲学

- 快速失败：尽早验证
- 具体明确：清晰的错误消息
- 不要信任：即使是“内部”数据

---

## 7. 安全原则

### 安全检查清单（非代码）

- [ ] **输入验证**：所有输入已经过验证
- [ ] **参数化查询**：SQL 无字符串拼接
- [ ] **密码哈希**：bcrypt 或 argon2
- [ ] **JWT 验证**：始终验证签名和过期
- [ ] **速率限制**：防止滥用
- [ ] **安全头**：Helmet.js 或同等工具
- [ ] **HTTPS**：生产环境全面使用
- [ ] **CORS**：正确配置
- [ ] **密钥**：仅使用环境变量
- [ ] **依赖**：定期审计

### 安全心态

```
什么都不信：
├── 查询参数 → 验证
├── 请求体 → 验证
├── Headers → 验证
├── Cookies → 验证
├── 文件上传 → 扫描
└── 外部 API → 验证响应
```

---

## 8. 测试原则

### 测试策略选择

| 类型                       | 目的     | 工具              |
| -------------------------- | -------- | ----------------- |
| **单元测试 (Unit)**        | 业务逻辑 | node:test, Vitest |
| **集成测试 (Integration)** | API 端点 | Supertest         |
| **端到端测试 (E2E)**       | 完整流程 | Playwright        |

### 测试什么（优先级）

1. **关键路径**：认证、支付、核心业务
2. **边缘情况**：空输入、边界
3. **错误处理**：失败时会发生什么？
4. **不值得测试**：框架代码、简单的 Getter

### 内置测试运行器 (Node.js 22+)

```
node --test src/**/*.test.ts
├── 无外部依赖
├── 良好的覆盖率报告
└── 支持监听 (Watch) 模式
```

---

## 10. 避免的反模式

### ❌ 不要：

- 在新的边缘项目中使用 Express（改用 Hono）
- 在生产代码中使用同步方法
- 将业务逻辑放在控制器中
- 跳过输入验证
- 硬编码密钥
- 无验证地信任外部数据
- 用 CPU 工作阻塞事件循环

### ✅ 要：

- 根据上下文选择框架
- 不清楚时询问用户偏好
- 为增长的项目使用分层架构
- 验证所有输入
- 使用环境变量存储密钥
- 优化前先分析 (Profile)

---

## 11. 决策检查清单

在实施之前：

- [ ] **询问过用户关于技术栈的偏好？**
- [ ] **为当前场景选择了框架？**（而非单纯默认）
- [ ] **考虑了部署目标？**
- [ ] **规划了错误处理策略？**
- [ ] **确定了验证点？**
- [ ] **考虑了安全需求？**

---

> **记住**：Node.js 最佳实践核心在于决策，而非死记硬背模式。每个项目都值得根据其需求进行重新审视。
