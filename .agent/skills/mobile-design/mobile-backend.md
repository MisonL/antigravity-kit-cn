# 移动端后端模式 (Mobile Backend Patterns)

> **本文件涵盖专门针对移动客户端的后端/API 模式。**
> 通用后端模式在 `nodejs-best-practices` 和 `api-patterns` 中。
> **移动端后端与 Web 后端不同。约束不同，模式不同。**

---

## 🧠 移动端后端思维 (Mobile Backend Mindset)

```
移动客户端与 Web 客户端不同:
├── 网络不可靠 (2G, 地铁, 电梯)
├── 电池约束 (最大限度减少唤醒)
├── 存储有限 (不能缓存所有内容)
├── 会话中断 (电话, 通知)
├── 设备多样化 (从旧手机到旗舰机)
└── 二进制更新缓慢 (App Store 审核)
```

**你的后端必须补偿所有这些问题。**

---

## 🚫 AI 移动后端反模式

### 这些是构建移动后端时常见的 AI 错误：

| ❌ AI 默认                 | 为什么是错的             | ✅ 移动端正确做法             |
| -------------------------- | ------------------------ | ----------------------------- |
| Web 和移动端使用相同的 API | 移动端需要紧凑的响应     | 独立的移动端端点 或 字段选择  |
| 完整的对象响应             | 浪费带宽、电池           | 部分响应、分页                |
| 不考虑离线                 | 无网络时应用崩溃         | 离线优先设计、同步队列        |
| WebSocket用于一切          | 耗电                     | 推送通知 + 轮询回退           |
| 无应用版本控制             | 无法强制更新，破坏性变更 | 版本头，最低版本检查          |
| 通用错误消息               | 用户无法修复问题         | 移动端特定错误代码 + 恢复操作 |
| 基于会话的认证             | 移动应用重启             | 基于 Token 的认证 + 刷新      |
| 忽略设备信息               | 无法调试问题             | 包含设备 ID、应用版本的请求头 |

---

## 1. 推送通知 (Push Notifications)

### 平台架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    你的后端 (YOUR BACKEND)                       │
├─────────────────────────────────────────────────────────────────┤
│                         │                                        │
│              ┌──────────┴──────────┐                            │
│              ▼                     ▼                            │
│    ┌─────────────────┐   ┌─────────────────┐                    │
│    │   FCM (Google)  │   │  APNs (Apple)   │                    │
│    │   Firebase      │   │  直接 或 FCM      │                    │
│    └────────┬────────┘   └────────┬────────┘                    │
│             │                     │                              │
│             ▼                     ▼                              │
│    ┌─────────────────┐   ┌─────────────────┐                    │
│    │  Android 设备    │   │    iOS 设备      │                    │
│    └─────────────────┘   └─────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
```

### 推送类型

| 类型               | 用例               | 用户看到       |
| ------------------ | ------------------ | -------------- |
| **显示 (Display)** | 新消息，订单更新   | 通知横幅       |
| **静默 (Silent)**  | 后台同步，内容更新 | 无 (后台运行)  |
| **数据 (Data)**    | 应用自定义处理     | 取决于应用逻辑 |

### 反模式

| ❌ 永远不要          | ✅ 务必                          |
| -------------------- | -------------------------------- |
| 在推送中发送敏感数据 | 推送仅告知"新消息"，App 拉取内容 |
| 推送过载             | 批处理，去重，尊重免打扰时间     |
| 向所有人发送相同消息 | 按用户偏好、时区进行分段         |
| 忽略失败的 Token     | 定期清理无效 Token               |
| iOS 跳过 APNs        | 单独使用 FCM 无法保证 iOS 投递   |

### Token 管理

```
TOKEN 生命周期:
├── App 注册 → 获取 Token → 发送给后端
├── Token 可能变更 → App 必须在启动时重新注册
├── Token 过期 → 从数据库清除
├── 用户卸载 → Token 失效 (通过错误检测)
└── 多设备 → 每个用户存储多个 Token
```

---

## 2. 离线同步与冲突解决

### 同步策略选择

```
数据类型是什么?
        │
        ├── 只读 (新闻, 目录)
        │   └── 简单缓存 + TTL
        │       └── ETag/Last-Modified 用于失效
        │
        ├── 用户所有 (笔记, 待办)
        │   └── 最后写入胜出 (简单)
        │       └── 或基于时间戳的合并
        │
        ├── 协作 (共享文档)
        │   └── 需要 CRDT 或 OT
        │       └── 考虑 Firebase/Supabase
        │
        └── 关键 (支付, 库存)
            └── 服务器是真理来源
                └── 乐观 UI + 服务器确认
```

### 冲突解决策略

| 策略             | 如何工作         | 最适合           |
| ---------------- | ---------------- | ---------------- |
| **最后写入胜出** | 最新时间戳覆盖   | 简单数据，单用户 |
| **服务器胜出**   | 服务器总是权威的 | 关键交易         |
| **客户端胜出**   | 离线更改优先     | 离线重度应用     |
| **合并 (Merge)** | 逐字段合并更改   | 文档，富内容     |
| **CRDT**         | 数学上无冲突     | 实时协作         |

### 同步队列模式

```
客户端:
├── 用户更改 → 写入本地 DB
├── 加入同步队列 → { action, data, timestamp, retries }
├── 网络可用 → FIFO 处理队列
├── 成功 → 从队列移除
├── 失败 → 带退避重试 (最大 5 次)
└── 冲突 → 应用解决策略

服务端:
├── 接收带客户端时间戳的更改
├── 与服务器版本比较
├── 应用冲突解决
├── 返回合并状态
└── 客户端用服务器响应更新本地
```

---

## 3. 移动端 API 优化

### 响应体积缩减

| 技术         | 节省   | 实现                        |
| ------------ | ------ | --------------------------- |
| **字段选择** | 30-70% | `?fields=id,name,thumbnail` |
| **压缩**     | 60-80% | gzip/brotli (自动)          |
| **分页**     | 不定   | 移动端基于游标 (Cursor)     |
| **图片变体** | 50-90% | `/image?w=200&q=80`         |
| **增量同步** | 80-95% | 仅自时间戳以来的变更记录    |

### 分页: 游标 vs 偏移量

```
OFFSET (对移动端不好):
├── Page 1: OFFSET 0 LIMIT 20
├── Page 2: OFFSET 20 LIMIT 20
├── 问题: 新增项目 → 重复!
└── 问题: 大偏移量 = 查询慢

CURSOR (对移动端好):
├── First: ?limit=20
├── Next: ?limit=20&after=cursor_abc123
├── Cursor = encoded (id + sort values)
├── 数据变更无重复
└── 性能一致
```

### 批量请求 (Batch Requests)

```
代替:
GET /users/1
GET /users/2
GET /users/3
(3 次往返, 3倍延迟)

使用:
POST /batch
{ requests: [
    { method: "GET", path: "/users/1" },
    { method: "GET", path: "/users/2" },
    { method: "GET", path: "/users/3" }
]}
(1 次往返)
```

---

## 4. 应用版本控制

### 版本检查端点

```
GET /api/app-config
Headers:
  X-App-Version: 2.1.0
  X-Platform: ios
  X-Device-ID: abc123

Response:
{
  "minimum_version": "2.0.0",
  "latest_version": "2.3.0",
  "force_update": false,
  "update_url": "https://apps.apple.com/...",
  "feature_flags": {
    "new_player": true,
    "dark_mode": true
  },
  "maintenance": false,
  "maintenance_message": null
}
```

### 版本比较逻辑

```
客户端版本 vs 最低版本:
├── client >= minimum → 正常继续
├── client < minimum → 显示强制更新屏幕
│   └── 阻止应用使用直到更新
└── client < latest → 显示可选更新提示

功能标志 (FEATURE FLAGS):
├── 无需更新应用即可启用/禁用功能
├── 按版本/设备进行 A/B 测试
└── 灰度发布 (10% → 50% → 100%)
```

---

## 5. 移动端认证

### Token 策略

```
ACCESS TOKEN (访问令牌):
├── 短生命周期 (15 分钟 - 1 小时)
├── 存储在内存中 (非持久化)
├── 用于 API 请求
└── 过期时刷新

REFRESH TOKEN (刷新令牌):
├── 长生命周期 (30-90 天)
├── 存储在 SecureStore/Keychain 中
├── 仅用于获取新的 Access Token
└── 每次使用时轮换 (安全)

DEVICE TOKEN (设备令牌):
├── 标识此设备
├── 允许 "注销所有设备"
├── 与 Refresh Token 一起存储
└── 服务器跟踪活跃设备
```

### 静默重新认证

```
请求流程:
├── 使用 Access Token 请求
├── 401 Unauthorized?
│   ├── 有 Refresh Token?
│   │   ├── 是 → 调用 /auth/refresh
│   │   │   ├── 成功 → 重试原始请求
│   │   │   └── 失败 → 强制注销
│   │   └── 否 → 强制注销
│   └── Token 刚刚过期 (非无效)
│       └── 自动刷新，用户无感知
└── 成功 → 继续
```

---

## 6. 移动端错误处理

### 移动端特定错误格式

```json
{
    "error": {
        "code": "PAYMENT_DECLINED",
        "message": "支付被拒绝",
        "user_message": "请检查您的银行卡详情或尝试其他支付方式",
        "action": {
            "type": "navigate",
            "destination": "payment_methods"
        },
        "retry": {
            "allowed": true,
            "after_seconds": 5
        }
    }
}
```

### 错误类别

| 代码范围 | 类别       | 移动端处理                 |
| -------- | ---------- | -------------------------- |
| 400-499  | 客户端错误 | 显示消息，需要用户操作     |
| 401      | 认证过期   | 静默刷新或重新登录         |
| 403      | 禁止       | 显示升级/权限屏幕          |
| 404      | 未找到     | 从本地缓存移除             |
| 409      | 冲突       | 显示同步冲突 UI            |
| 429      | 速率限制   | 响应头后重试，退避         |
| 500-599  | 服务器错误 | 带退避重试，显示"稍后再试" |
| Network  | 无连接     | 使用缓存数据，排队同步     |

---

## 7. 媒体与二进制处理

### 图片优化

```
客户端请求:
GET /images/{id}?w=400&h=300&q=80&format=webp

服务器响应:
├── 即时调整大小 或 使用 CDN
├── Android 使用 WebP (更小)
├── iOS 14+ 使用 HEIC (如果支持)
├── JPEG 回退
└── Cache-Control: max-age=31536000
```

### 分块上传 (大文件)

```
上传流程:
1. POST /uploads/init
   { filename, size, mime_type }
   → { upload_id, chunk_size }

2. PUT /uploads/{upload_id}/chunks/{n}
   → 上传每个块 (1-5 MB)
   → 如果中断可恢复

3. POST /uploads/{upload_id}/complete
   → 服务器组装块
   → 返回最终文件 URL
```

### 流式音频/视频

```
需求:
├── iOS 使用 HLS (HTTP Live Streaming)
├── Android 使用 DASH 或 HLS
├── 多个质量级别 (自适应码率)
├── 支持范围请求 (Range request) (拖动进度条)
└── 离线下载块

端点:
GET /media/{id}/manifest.m3u8  → HLS 清单
GET /media/{id}/segment_{n}.ts → 视频片段
GET /media/{id}/download       → 完整文件用于离线
```

---

## 8. 移动端安全

### 设备证明 (Device Attestation)

```
验证真实设备 (非模拟器/机器人):
├── iOS: DeviceCheck API
│   └── 服务器与 Apple 验证
├── Android: Play Integrity API (替代 SafetyNet)
│   └── 服务器与 Google 验证
└── 失败关闭: 如果证明失败则拒绝
```

### 请求签名

```
客户端:
├── 创建签名 = HMAC(timestamp + path + body, secret)
├── 发送: X-Signature: {signature}
├── 发送: X-Timestamp: {timestamp}
└── 发送: X-Device-ID: {device_id}

服务器:
├── 验证时间戳 (5分钟内)
├── 使用相同输入重新创建签名
├── 比较签名
└── 如果不匹配则拒绝 (检测到篡改)
```

### 速率限制

```
移动端特定限制:
├── 每一设备 (X-Device-ID)
├── 每一用户 (认证后)
├── 每一端点 (敏感操作更严)
└── 首选滑动窗口

响应头:
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1609459200
Retry-After: 60 (当 429 时)
```

---

## 9. 监控与分析

### 移动端必需请求头

```
每个移动端请求应包含:
├── X-App-Version: 2.1.0
├── X-Platform: ios | android
├── X-OS-Version: 17.0
├── X-Device-Model: iPhone15,2
├── X-Device-ID: uuid (持久化)
├── X-Request-ID: uuid (每个请求，用于链路追踪)
├── Accept-Language: tr-TR
└── X-Timezone: Europe/Istanbul
```

### 记录什么

```
对于每个请求:
├── 所有上述请求头
├── 端点, 方法, 状态
├── 响应时间
├── 错误详情 (如果有)
└── 用户 ID (如果已认证)

告警:
├── 每个版本的错误率 > 5%
├── P95 延迟 > 2 秒
├── 特定版本崩溃激增
├── 认证失败激增 (攻击?)
└── 推送投递失败激增
```

---

## 📝 移动后端检查清单

### API 设计前

- [ ] 识别移动端特定需求?
- [ ] 计划离线行为?
- [ ] 设计同步策略?
- [ ] 考虑带宽限制?

### 对于每个端点

- [ ] 响应尽可能小?
- [ ] 基于游标的分页?
- [ ] 正确的缓存头?
- [ ] 带操作的移动端错误格式?

### 认证

- [ ] 实现了 Token 刷新?
- [ ] 静默重新认证流程?
- [ ] 多设备注销?
- [ ] 安全 Token 存储指南?

### 推送通知

- [ ] 配置了 FCM + APNs?
- [ ] 管理了 Token 生命周期?
- [ ] 定义了静默与显示推送?
- [ ] 推送负载中**不**包含敏感数据?

### 发布

- [ ] 版本检查端点就绪?
- [ ] 功能标志已配置?
- [ ] 强制更新机制?
- [ ] 必需的监控请求头?

---

> **记住:** 移动后端必须对糟糕的网络具有弹性，尊重电池寿命，并优雅地处理中断的会话。客户端不可信，但也绝不能让它挂起——提供离线能力和清晰的错误恢复路径。
