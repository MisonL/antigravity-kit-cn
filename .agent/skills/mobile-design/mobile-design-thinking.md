---
description: 移动端优先设计思维、反默认模式与AI对策
---

# 移动端设计思维 (Mobile Design Thinking)

> **此文件旨在防止 AI 使用死记硬背的模式，并强制进行真正的思考。**
> 这是防止移动开发中标准 AI 训练默认值的机制。
> **相当于前端的布局分解方法，但针对移动端。**

---

## 🧠 深度移动思维协议 (Deep Mobile Thinking Protocol)

### 每个移动项目前的强制流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    深度移动思维 (DEEP MOBILE THINKING)           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1️⃣ 上下文扫描 (CONTEXT SCAN)                                   │
│     └── 我对此项目的假设是什么？                                │
│         └── 质疑这些假设                                        │
│                                                                 │
│  2️⃣ 反默认分析 (ANTI-DEFAULT ANALYSIS)                          │
│     └── 我是否在应用死记硬背的模式？                            │
│         └── 这个模式真的适合 *这个* 项目吗？                    │
│                                                                 │
│  3️⃣ 平台分解 (PLATFORM DECOMPOSITION)                           │
│     └── 我是否分别考虑了 iOS 和 Android？                       │
│         └── 平台特定的模式是什么？                              │
│                                                                 │
│  4️⃣ 触摸交互分解 (TOUCH INTERACTION BREAKDOWN)                  │
│     └── 我是否单独分析了每个交互？                              │
│         └── 是否应用了菲茨定律、拇指热区？                      │
│                                                                 │
│  5️⃣ 性能影响分析 (PERFORMANCE IMPACT ANALYSIS)                  │
│     └── 我是否考虑了每个组件的性能影响？                        │
│         └── 默认解决方案是否高性能？                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🚫 AI 移动端默认值 (禁止列表)

### 自动使用这些模式是**禁止**的！

以下是 AI 从训练数据中学到的"默认"模式。
在使用其中任何一个之前，**质疑它们并考虑替代方案！**

```
┌─────────────────────────────────────────────────────────────────┐
│                 🚫 AI 移动端避风港                              │
│           (默认模式 - 在质疑之前绝不使用)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  导航默认值:                                                    │
│  ├── 每个项目都用 Tab bar (抽屉导航会不会更好？)                │
│  ├── 固定的 5 个标签 (3 个够吗？超过 6 个用抽屉？)              │
│  ├── 左侧是"主页" (用户行为数据怎么说？)                        │
│  └── 汉堡菜单 (它现在过时了吗？)                                │
│                                                                 │
│  状态管理默认值:                                                │
│  ├── 到处都用 Redux (Zustand/Jotai 是否足够？)                  │
│  ├── 一切都用全局状态 (本地状态不够吗？)                        │
│  ├── Context Provider 地狱 (原子化状态是否更好？)               │
│  └── 每个 Flutter 项目都用 BLoC (Riverpod 是否更现代？)         │
│                                                                 │
│  列表实现默认值:                                                │
│  ├── 默认用 FlatList (FlashList 性能是否更好？)                 │
│  ├── windowSize=21 (真的需要吗？)                               │
│  ├── removeClippedSubviews (总是需要？)                         │
│  ├── ListView.builder (ListView.separated 是否更好？)           │
│                                                                 │
│  UI 模式默认值:                                                 │
│  ├── FAB 在右下角 (左下角是否更易于访问？)                      │
│  ├── 每个列表都下拉刷新 (真的到处都需要吗？)                    │
│  ├── 左滑删除 (右滑是否更好？)                                  │
│  ├── 每个模态都用 Bottom sheet (全屏是否更好？)                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🔍 组件分解 (强制性)

### 每个屏幕的分解分析

在设计任何屏幕之前，执行此分析：

```
屏幕: [屏幕名称]
├── 主要操作: [主要动作是什么？]
│   └── 它在拇指热区吗？ [是/否 → 为什么？]
│
├── 触摸目标: [所有可点击元素]
│   ├── [元素 1]: [尺寸]pt → 足够吗？
│   ├── [元素 2]: [尺寸]pt → 足够吗？
│   └── 间距: [间隙]pt → 误触风险？
│
├── 可滚动内容:
│   ├── 是列表吗？ → FlatList/FlashList [为什么选这个？]
│   ├── 项目数量: ~[N] → 性能考量？
│   └── 固定高度？ → 需要 getItemLayout 吗？
│
├── 状态需求:
│   ├── 本地状态足够吗？
│   ├── 需要提升状态吗？
│   └── 需要全局状态吗？ [为什么？]
│
├── 平台差异:
│   ├── iOS: [需要什么不同？]
│   └── Android: [需要什么不同？]
│
├── 离线考量:
│   ├── 此屏幕应在离线时工作吗？
│   └── 缓存策略: [是/否/哪种？]
│
└── 性能影响:
    ├── 有重型组件吗？
    ├── 需要 Memoization 吗？
    └── 动画性能？
```

---

## 🎯 模式质疑矩阵

对每个默认模式提出这些问题：

### 导航模式质疑

| 假设             | 问题               | 替代方案                     |
| :--------------- | :----------------- | :--------------------------- |
| "我要用 Tab bar" | 有多少目的地？     | 3 个 → 极简 Tabs，6+ → 抽屉  |
| "5 个标签"       | 它们同等重要吗？   | "更多"标签？抽屉混合？       |
| "底部导航"       | iPad/平板支持？    | 侧边导航栏 (Navigation rail) |
| "栈导航"         | 考虑了深度链接吗？ | URL 结构 = 导航结构          |

### 状态模式质疑

| 假设               | 问题                   | 替代方案                        |
| :----------------- | :--------------------- | :------------------------------ |
| "我要用 Redux"     | App 有多复杂？         | 简单: Zustand, 服务器: TanStack |
| "全局状态"         | 这状态真的是全局的吗？ | 本地提升, Context selector      |
| "Context Provider" | 重渲染会是个问题吗？   | Zustand, Jotai (原子化)         |
| "BLoC 模式"        | 样板代码值得吗？       | Riverpod (代码更少)             |

### 列表模式质疑

| 假设              | 问题                     | 替代方案                 |
| :---------------- | :----------------------- | :----------------------- |
| "FlatList"        | 性能关键吗？             | FlashList (更快)         |
| "标准 renderItem" | 被缓存 (memoized) 了吗？ | useCallback + React.memo |
| "Index key"       | 数据顺序会变吗？         | 使用 item.id             |
| "ListView"        | 有分隔线吗？             | ListView.separated       |

### UI 模式质疑

| 假设                | 问题                 | 替代方案           |
| :------------------ | :------------------- | :----------------- |
| "FAB 右下角"        | 用户惯用手？         | 辅助功能设置       |
| "下拉刷新"          | 这个列表需要刷新吗？ | 仅在必要时         |
| "模态 Bottom sheet" | 内容量多少？         | 全屏模态可能更好   |
| "滑动操作"          | 可发现性？           | 可见的按钮替代方案 |

---

## 🧪 反背诵测试 (Anti-Memorization Test)

### 每个解决方案前问自己

```
┌─────────────────────────────────────────────────────────────────┐
│                    反背诵检查清单 (ANTI-MEMORIZATION)           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  □ 我选这个方案是"因为我总是这样做"吗？                         │
│    → 如果是: 停止。考虑替代方案。                               │
│                                                                 │
│  □ 这是我在训练数据中经常看到的模式吗？                         │
│    → 如果是: 它真的适合 *这个* 项目吗？                         │
│                                                                 │
│  □ 我是否未加思索地自动写下了这个方案？                         │
│    → 如果是: 后退一步，做分解。                                 │
│                                                                 │
│  □ 我考虑过替代方法吗？                                         │
│    → 如果否: 想出至少 2 个替代方案，然后决定。                  │
│                                                                 │
│  □ 我是否从平台特定的角度思考了？                               │
│    → 如果否: 分别分析 iOS 和 Android。                          │
│                                                                 │
│  □ 我是否考虑了这个方案的性能影响？                             │
│    → 如果否: 内存、CPU、电池影响是什么？                        │
│                                                                 │
│  □ 这个方案适合 *这个* 项目的上下文吗？                         │
│    → 如果否: 根据上下文定制。                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 📊 基于上下文的决策协议

### 根据项目类型进行不同思考

```
确定项目类型:
        │
        ├── 电商应用 (E-Commerce)
        │   ├── 导航: Tab (首页, 搜索, 购物车, 账户)
        │   ├── 列表: 商品网格 (高度缓存, 图片优化)
        │   ├── 性能: 图片缓存至关重要
        │   ├── 离线: 购物车持久化, 商品缓存
        │   └── 特殊: 结账流程, 支付安全
        │
        ├── 社交/内容应用
        │   ├── 导航: Tab (信息流, 搜索, 发布, 通知, 个人)
        │   ├── 列表: 无限滚动, 复杂项
        │   ├── 性能: 信息流渲染至关重要
        │   ├── 离线: 信息流缓存, 草稿箱
        │   └── 特殊: 实时更新, 媒体处理
        │
        ├── 生产力/SaaS 应用
        │   ├── 导航: 抽屉 或 自适应 (手机 Tab, 平板 Rail)
        │   ├── 列表: 数据表格, 表单
        │   ├── 性能: 数据同步
        │   ├── 离线: 全功能离线编辑
        │   └── 特殊: 冲突解决, 后台同步
        │
        ├── 工具类应用
        │   ├── 导航: 极简 (可能仅 Stack)
        │   ├── 列表: 可能很少
        │   ├── 性能: 快速启动
        │   ├── 离线: 核心功能离线
        │   └── 特殊: 小组件, 快捷方式
        │
        └── 媒体/流媒体应用
            ├── 导航: Tab (首页, 搜索, 库, 个人)
            ├── 列表: 横向轮播, 纵向 Feeds
            ├── 性能: 预加载, 缓冲
            ├── 离线: 下载管理
            └── 特殊: 后台播放, 投屏
```

---

## 🔄 交互分解

### 分析每个手势

在添加任何手势之前：

```
手势: [手势类型]
├── 可发现性:
│   └── 用户将如何发现此手势？
│       ├── 有视觉提示吗？
│       ├── 会在引导页展示吗？
│       └── 有按钮替代方案吗？ (强制性)
│
├── 平台惯例:
│   ├── 这个手势在 iOS 上意味着什么？
│   ├── 这个手势在 Android 上意味着什么？
│   └── 我是否偏离了平台惯例？
│
├── 可访问性:
│   ├── 运动障碍用户能执行此手势吗？
│   ├── 有 VoiceOver/TalkBack 替代方案吗？
│   └── 它支持切换控制 (Switch Control) 吗？
│
├── 冲突检查:
│   ├── 它与系统手势冲突吗？
│   │   ├── iOS: 边缘右滑返回
│   │   ├── Android: 返回手势
│   │   └── Home 指示器上滑
│   └── 它与其他 App 手势一致吗？
│
└── 反馈:
    ├── 定义了触觉反馈吗？
    ├── 视觉反馈足够吗？
    └── 需要音频反馈吗？
```

---

## 🎭 精神重于清单 (移动版)

### 通过清单是不够的！

| ❌ 自我欺骗                          | ✅ 诚实评估                                   |
| :----------------------------------- | :-------------------------------------------- |
| "触摸目标是 44px" (但在边缘，够不着) | "用户能单手够到它吗？"                        |
| "我用了 FlatList" (但没缓存)         | "滚动顺滑吗？"                                |
| "平台特定导航" (但只有图标不同)      | "iOS 感觉像 iOS，Android 感觉像 Android 吗？" |
| "有离线支持" (但错误信息是通用的)    | "用户离线时实际上能做什么？"                  |
| "有加载状态" (但只是个转圈)          | "用户知道要等多久吗？"                        |

> 🔴 **通过清单不是目标。创造卓越的移动 UX 才是目标。**

---

## 📝 移动设计承诺书

### 每个移动项目开始时填写

```
📱 移动设计承诺书

项目: _______________
平台: iOS / Android / Both

1. 我在本项目中 **不会** 使用的默认模式:
   └── _______________

2. 本项目的特定上下文焦点:
   └── _______________

3. 我将实现的平台特定差异:
   └── iOS: _______________
   └── Android: _______________

4. 我将特别优化性能的区域:
   └── _______________

5. 本项目的独特挑战:
   └── _______________

🧠 如果我填不出这份承诺书 → 我对项目理解不够。
   → 回去，更好地理解上下文，询问用户。
```

---

## 🚨 强制：每次移动开发前

```
┌─────────────────────────────────────────────────────────────────┐
│                    预研验证 (PRE-WORK VALIDATION)               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  □ 我完成了组件分解吗？                                         │
│  □ 我填写了模式质疑矩阵吗？                                     │
│  □ 我通过了反背诵测试吗？                                       │
│  □ 我做出了基于上下文的决策吗？                                 │
│  □ 我分析了交互分解吗？                                         │
│  □ 我填写了移动设计承诺书吗？                                   │
│                                                                 │
│  ⚠️ 未完成这些之前不要写代码！                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

> **记住:** 如果你选择一个解决方案是"因为一直都是这样做的"，那么你是在**没有思考**的情况下选择的。每个项目都是独特的。每个上下文都是不同的。每个用户行为都是特定的。**先思考，再编码。**
