# 3. 服务端性能优化 (Server-Side Performance)

> **影响等级:** 高 (HIGH)
> **核心关注:** 优化服务端渲染与数据获取，消除服务端瀑布流并减少响应时间。

---

## 规则 3.1: 像对待 API 路由一样鉴权 Server Actions

**影响: 关键 (CRITICAL)**
Server Actions (`"use server"`) 本质上是公开的 HTTP 端点。

- **要求**: 必须在 Action **内部**执行身份验证和授权检查，绝不能仅依赖中间件或页面级拦截。

---

## 规则 3.2: 消除 RSC Props 中的重复序列化

RSC 到客户端的序列化是针对对象引用去重的。

- **优化**: 在客户端而非服务端执行 `.filter()` 或 `.map()` 转换，以避免同一份数据在 Props 中被多次序列化。

---

## 规则 3.3: 跨请求 LRU 缓存 (Cross-Request LRU Cache)

`React.cache()` 仅在单个请求生命周期内有效。

- **场景**: 对于多个连续请求（如用户点击 A 按钮后点击 B 按钮）共享的数据，应在模块级使用 `lru-cache` 进行持久化缓存。

---

## 规则 3.4: 最小化 RSC 边界序列化开销

Props 中的冗余字段会显著增加 HTML 体积。

- **反模式**: 将拥有 50 个字段的完整 User 对象传给客户端，但客户端仅使用了 `name` 字段。
- **推荐**: 仅传递客户端所需的最小字段集。

---

## 规则 3.5: 通过组件组合实现并行数据获取

React 服务端组件默认在树中顺序执行。

- **优化**: 使用“组合模式”将各个 Fetching 组件并行化，而非在父组件中 await 所有的 fetch。

---

## 规则 3.6: 使用 React.cache() 进行单请求去重

- **用途**: 针对数据库查询、身份验证检查等非 Fetch 异步操作。
- **注意**: 避免传入内联对象作为参数，因为 `React.cache` 使用 `Object.is` 判断，内联对象会导致缓存失效。

---

## 规则 3.7: 使用 after() 执行非阻塞操作

- **场景**: 日志记录、分析追踪、审计日志发送、缓存清理。
- **优点**: 将非核心副作用移至响应发送**之后**执行，从而缩短 TTFB (首字节时间)。

---

> **记住：** 服务端的时间极其宝贵。通过并行化与去重，让你的应用响应如丝般顺滑。
