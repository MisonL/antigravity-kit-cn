# 模式选择指南

> 选择架构模式的决策树。

## 主决策树

```
开始：你的主要关注点是什么？

┌─ 数据访问复杂度？
│  ├─ 高（复杂查询，需要测试）
│  │  → Repository Pattern（仓储模式）+ Unit of Work（工作单元）
│  │  验证：数据源会频繁变化吗？
│  │     ├─ 是 → Repository 值得增加间接层
│  │     └─ 否 → 考虑更简单的 ORM 直连访问
│  └─ 低（简单 CRUD，单一数据库）
│     → ORM 直连（Prisma, Drizzle）
│     越简单 = 越好、越快
│
├─ 业务规则复杂度？
│  ├─ 高（领域逻辑复杂，规则随上下文变化）
│  │  → Domain-Driven Design（DDD）
│  │  验证：团队里有领域专家吗？
│  │     ├─ 是 → Full DDD（聚合、值对象）
│  │     └─ 否 → Partial DDD（富实体、清晰边界）
│  └─ 低（主要是 CRUD，简单校验）
│     → Transaction Script pattern（事务脚本模式）
│     越简单 = 越好、越快
│
├─ 需要独立扩缩吗？
│  ├─ 是（不同组件扩缩方式不同）
│  │  → Microservices（微服务）值得承担复杂性
│  │  要求（必须全部满足）：
│  │    - 清晰的领域边界
│  │    - 团队 > 10 名开发者
│  │    - 各服务有不同的扩缩需求
│  │  未全部满足 → Modular Monolith（模块化单体）
│  └─ 否（整体一起扩缩）
│     → Modular Monolith（模块化单体）
│     以后在确有必要时再拆服务
│
└─ 实时性需求？
   ├─ 高（即时更新，多用户同步）
   │  → Event-Driven Architecture（事件驱动架构）
   │  → Message Queue（消息队列）（RabbitMQ, Redis, Kafka）
   │  验证：你能处理最终一致性吗？
   │     ├─ 是 → 事件驱动可行
   │     └─ 否 → 同步 + 轮询
   └─ 低（可接受最终一致性）
      → 同步（REST/GraphQL）
      越简单 = 越好、越快
```

## 三个问题（选择任何模式前）

1. **问题是否被解决**：该模式解决的具体问题是什么？
2. **更简单的替代方案**：是否存在更简单的方案？
3. **延迟复杂性**：能否在必要时再引入该模式？

## 红旗（反模式）

| 模式 | 反模式 | 更简单的替代方案 |
| ---- | ------ | ---------------- |
| Microservices（微服务） | 过早拆分 | 从单体开始，后续再拆 |
| Clean/Hexagonal（整洁/六边形） | 过度抽象 | 先写具体实现，后引入接口 |
| Event Sourcing（事件溯源） | 过度设计 | 追加式审计日志 |
| CQRS（命令查询职责分离） | 不必要的复杂性 | 单一模型 |
| Repository（仓储模式） | 对简单 CRUD 的 YAGNI（你不会需要它） | ORM 直连 |
