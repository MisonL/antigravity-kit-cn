# 模式选择指南 (Pattern Selection Guidelines)

> 选择架构模式的决策树。

## 主决策树

```
开始: 您的核心关注点是什么？

┌─ 数据访问复杂吗？
│  ├─ 高 (复杂查询, 需要测试)
│  │  → Repository 模式 + Unit of Work
│  │  验证: 数据源会频繁变化吗？
│  │     ├─ 是 → 值得使用 Repository 进行间接层拆解
│  │     └─ 否 → 考虑更简单的 ORM 直连访问
│  └─ 低 (简单 CRUD, 单一数据库)
│     → 直接使用 ORM (Prisma, Drizzle)
│     越简单 = 越好, 越快
│
├─ 业务规则复杂吗？
│  ├─ 高 (领域逻辑复杂, 规则随上下文变化)
│  │  → 领域驱动设计 (DDD)
│  │  验证: 团队中有领域专家吗？
│  │     ├─ 是 → 完整 DDD (聚合根, 值对象)
│  │     └─ 否 → 部分 DDD (丰富实体类, 清晰边界)
│  └─ 低 (大部分是 CRUD, 简单的验证)
│     → 事务脚本模式 (Transaction Script)
│     越简单 = 越好, 越快
│
├─ 需要独立扩展吗？
│  ├─ 是 (不同组件的扩展需求不同)
│  │  → 微服务架构 (值得承担其复杂性)
│  │  需求前提 (必须全部满足):
│  │    - 清晰的领域边界
│  │    - 团队规模 > 10 名开发者
│  │    - 每个服务有不同的扩展需求
│  │  若未全部满足 → 采用模块化单体 (Modular Monolith)
│  └─ 否 (所有组件一起扩展)
│     → 模块化单体
│     在证明确有必要时，再在以后提取服务
│
└─ 实时性需求高吗？
   ├─ 高 (即时更新, 多用户同步)
   │  → 事件驱动架构 (EDA)
   │  → 消息队列 (RabbitMQ, Redis, Kafka)
   │  验证: 您能处理最终一致性吗？
   │     ├─ 是 → 事件驱动方案有效
   │     └─ 否 → 同步调用 + 轮询
   └─ 低 (可以接受最终一致性)
      → 同步通信 (REST/GraphQL)
      越简单 = 越好, 越快
```

## 三大核心问题 (采用任何模式前)

1. **解决的问题**: 这种模式具体解决了什么特定的问题？
2. **更简单的替代方案**: 是否存在更简单的解决方案？
3. **延迟复杂性**: 能否在以后有需要时再添加该模式？

## 红旗/警告 (反模式 - Anti-patterns)

| 模式                      | 反模式 (Anti-pattern)  | 简单的替代               |
| :------------------------ | :--------------------- | :----------------------- |
| 微服务                    | 过早拆分               | 从单体开始，稍后提取     |
| 清洁/六边形架构           | 过度抽象               | 先写具体实现，后提取接口 |
| 事件溯源 (Event Sourcing) | 过度设计               | 仅使用追加式审计日志     |
| CQRS                      | 不必要的复杂性         | 单一模型                 |
| Repository                | 对简单 CRUD 的过度封装 | 直接使用 ORM             |
